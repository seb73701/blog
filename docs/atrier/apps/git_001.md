---
title: GitHub Actions en action
description: 
published: true
date: 2023-06-17T06:39:05.139Z
tags: 
editor: markdown
dateCreated: 2023-06-17T06:27:36.740Z
---

# GitHub Actions en‚Ä¶ action !

Pendant la [conf√©rence Cloud Nord](https://cloudnord.fr/) en novembre 2020, j‚Äôai d√©couvert le dernier n√© du monde de la CI/CD : GitHub Actions. Le but de cet article est de pr√©senter l‚Äôoutil via un exemple concret de d√©ploiement d‚Äôune application Java sur AWS dans un monorepo qui contiendra :

- une application Java Hello World d√©ploy√©e dans un container Docker ;
- le code Terraform pour la gestion de l‚Äôinfrastructure sur AWS ;
- les fichiers de configuration GitHub Actions permettant de garantir la qualit√© du code, de lancer les tests et d‚Äôorchestrer le d√©ploiement.

## Cr√©ation d‚Äôun premier workflow pour cr√©er l‚Äôinfrastructure sur AWS
> L‚Äôensemble du code pr√©sent√© ci-dessous se trouve sur [ce repository GitHub](https://github.com/taufort/github-actions-in-action).

Le premier module de notre monorepo se pr√©nomme `base-infrastructure`. Il contient le code Terraform d√©crivant notre infrastructure de base : un Virtual Private Cloud (VPC), un Application Load Balancer (ALB) et un cluster Elastic Container Service (ECS) Fargate.

Le workflow, c‚Äôest le point d‚Äôentr√©e dans GitHub Actions. C‚Äôest une proc√©dure automatis√©e qui d√©finit plusieurs √©tapes. Un workflow doit √™tre mis dans le dossier `.github/workflows/` d‚Äôun projet. Un projet peut avoir plusieurs workflows. Ces derniers seront lanc√©s en parall√®le.

Commen√ßons donc par cr√©er un premier workflow `base-infrastructure.yml` :

```yaml
name: base-infrastructure

on:
  push:
    branches:
      - main
  pull_request:

defaults:
  run:
    shell: bash

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
```

Apr√®s avoir nomm√© notre workflow, nous d√©finissons sur quels √©v√®nements (events) il se d√©clenche. Ils peuvent √™tre :

- **li√©s au cycle de vie du code** : push, cr√©ation d‚Äôune release, cr√©ation/fermeture d‚Äôune Pull Request (PR), cr√©ation d‚Äôun commentaire sur une PR, ajout d‚Äôun label...
- **li√©s au cycle de vie d‚Äôun projet GitHub** : cr√©ation d‚Äôune issue, ajout d‚Äôun commentaire sur une issue, cr√©ation d‚Äôun label, cr√©ation d‚Äôun projet GitHub‚Ä¶
- **programm√©s** via un cron.

La liste de ces √©v√©nements est pr√©sente sur la [documentation](https://docs.github.com/en/actions/reference/events-that-trigger-workflows). Dans cet exemple, le workflow se d√©clenche sur deux choses :

- un push sur la branche main
- n‚Äôimporte quel event de type pull_request

On d√©finit ensuite des attributs globaux √† l‚Äôensemble du workflow, on indique le shell par d√©faut √† utiliser dans les jobs. Un job est un ensemble d‚Äô√©tapes (steps) qui sont lanc√©es sur un m√™me runner (machine virtuelle).

On utilise √©galement la directive `env` pour injecter des variables d‚Äôenvironnement. On y ins√®re ici des secrets du repository pr√©alablement enregistr√©s dans les param√®tres du projet GitHub, √† savoir les credentials AWS. Pour acc√©der √† des informations du contexte GitHub de votre workflow, il faut utiliser une syntaxe sp√©cifique pour √©valuer des expressions, √† savoir `${{ <expression> }}` (les noms des contextes sont nombreux, n‚Äôh√©sitez pas √† aller [les consulter](https://docs.github.com/en/free-pro-team@latest/actions/reference/context-and-expression-syntax-for-github-actions)).

Passons maintenant au premier job :

```yaml
jobs:
  terraform:
    defaults:
      run:
        working-directory: base-infrastructure/.cloud/terraform
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        id: checkout
        uses: actions/checkout@v2
      - name: Setup Terraform
        id: setup
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: 0.14.7
          terraform_wrapper: false
      - name: Terraform Format
        id: fmt
        run: terraform fmt -check -recursive
      - name: Terraform init without backend
        id: init-without-backend
        run: terraform init -backend=false
      - name: Terraform validate
        id: validate
        run: terraform validate
```

Ce premier job s‚Äôappelle `terraform`, il sera lanc√© sur un runner Ubuntu avec la version la plus r√©cente et le dossier de travail par d√©faut est `base-infrastructure/.cloud/terraform`. Arrivent ensuite les diff√©rentes √©tapes du job.

> C‚Äôest une bonne pratique de sp√©cifier un name et un id pour chacune des √©tapes (steps) d‚Äôun job. Le name permettra de faciliter la lecture dans la sortie console de GitHub Actions et l‚Äôid permettra d‚Äôidentifier un step de fa√ßon unique.

Deux des steps font appel √† des actions et les trois autres lancent des commandes Terraform via le shell de l‚ÄôOperating System (OS) du runner.

Les actions sont des modules externes ([publi√©s sur le GitHub Marketplace](https://github.com/marketplace?type=actions)) qui peuvent √™tre de diff√©rents types : Docker,  JavaScript ou encore Composite run steps. Nous ne rentrerons pas dans les d√©tails de tous les types d‚Äôaction, [la documentation GitHub](https://docs.github.com/en/actions/creating-actions/about-actions) le fait tr√®s bien. Les deux actions que nous appelons ici sont des actions JavaScript. La premi√®re action (`uses: actions/checkout@v2`) va permettre de r√©cup√©rer le code du projet et la seconde (`uses: hashicorp/setup-terraform@v1`) va configurer Terraform √† l‚Äôendroit o√π s‚Äôex√©cute notre job (cela peut √™tre le host GitHub Actions ou bien un container Docker).

Continuons avec les √©tapes suivantes :

```yaml
      - name: Terraform init
        id: init
        run: terraform init
      - name: Terraform plan
        id: plan
        run: terraform plan -no-color -out=tfplan.out
      - name: Terraform apply
        id: apply
        if: github.ref == 'refs/heads/main'
        run: terraform apply -input=false tfplan.out
        continue-on-error: true
```

L‚Äô√©tape `apply` nous am√®ne la directive `if: github.ref == 'refs/heads/main'`. Elle permet de lancer une √©tape sur une condition donn√©e. Ici, on limite les `terraform apply` √† la branche git `main`.

La directive `continue-on-error: true` indique que l‚Äô√©tape peut √™tre en √©chec sans mettre l‚Äôensemble du workflow en √©chec.

Passons aux √©tapes suivantes :

> **Dans le code ci-dessous, il y a des emojis √† la place des caract√®res.**
{.is-warning}


```yaml
 - name: Create a new GitHub issue if the apply failed
        id: create-github-issue-if-apply-failed
        uses: actions/github-script@v3
        if: github.ref == 'refs/heads/main' && steps.apply.outcome == 'failure'
        env:
          PLAN: "terraform\n${{ steps.plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Terraform Initialization ‚öôÔ∏è\`${{ steps.init.outcome }}\`
            #### Terraform plan which provoked a Terraform apply failure üìñ \`${{ steps.plan.outcome }}\`
            <details><summary>Show Plan</summary>\n
            \`\`\`${process.env.PLAN}\`\`\`
            </details>\n
            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

            github.issues.create({
              title: 'Terraform apply failed on main branch',
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output,
              labels: ['Triage', 'Bug']
            })
      - name: Terraform apply status
        id: apply-status
        if: github.ref == 'refs/heads/main' && steps.apply.outcome == 'failure'
        run: exit 1
```

L‚Äô√©tape `create-github-issue-if-apply-failed` est un cas d‚Äôutilisation int√©ressant d'interaction avec l‚ÄôAPI GitHub. Cette √©tape est d√©clench√©e si et seulement si on est sur la branche `main` et si l‚Äô√©tape `apply` pr√©c√©demment jou√©e a √©chou√©. Pour cela, on fait appel √† l‚Äôaction `actions/github-script@v3` qui prend en param√®tres le token GitHub ainsi qu‚Äôun script √©crit en JavaScript (qui a dit que les consultants pratiquant le DevOps ne faisaient que du YAML ?) afin de cr√©er une issue GitHub contenant le plan Terraform ayant fait √©chouer le workflow de la branche `main`. Enfin, l‚Äô√©tape `apply-status` permet de faire √©chouer le workflow dans le cas o√π l‚Äô√©tape `apply` aurait √©chou√©.

Et voil√† le r√©sultat du workflow dans GitHub Actions :

![first_workflow.png](/assets/img/developpement/tempo/first_workflow.png)

## Cr√©ation de notre premi√®re action
Le second module du monorepo s‚Äôappelle `gateway`. Il contient le code Java de notre application Hello World et deux autres sous-modules avec du code Terraform. Le premier sert √† cr√©er un repository Elastic Container Registry (ECR) pour h√©berger l‚Äôimage Docker de l‚Äôapplication Java. Le second permet de d√©ployer cette m√™me image sur le cluster ECS Fargate.

Le premier workflow GitHub pr√©sent√© pr√©c√©demment contenait des t√¢ches assez g√©n√©riques pour valider et appliquer du code Terraform. Comment pourrions-nous rendre ce code r√©utilisable pour l‚Äôutiliser dans un nouveau workflow pour le second module `gateway` ?  Cr√©ons une action de type Composite run steps pour r√©soudre cette probl√©matique.

Comme nous ne souhaitons pas dans un premier temps partager cette action √† la communaut√©, nous allons placer cette derni√®re dans le dossier `.github/actions/` du repository de code. Ceci √©tant, si vous souhaitez partager votre action √† la communaut√©, c‚Äôest tout √† fait possible. Il faudra cr√©er un [nouveau repository sur GitHub afin de pouvoir versionner votre action](https://docs.github.com/en/actions/creating-actions/about-actions#choosing-a-location-for-your-action).

Voici notre premi√®re action `.github/actions/terraform-workflow/action.yml`:

```yaml
name: 'Terraform workflow'
author: Timoth√©e Aufort
description: 'A common workflow of Terraform commands'
inputs:
  working-directory:
    description: 'Working directory for this action'
    required: false
    default: '.'
  apply:
    description: 'Do you want to apply the Terraform plan at the end of the process?'
    required: false
    default: 'true'
runs:
  using: "composite"
  steps:
    - name: Terraform Format
      id: fmt
      run: terraform fmt -check -recursive
      shell: bash
      working-directory: ${{ inputs.working-directory }}
    - name: Terraform init without backend
      id: init-without-backend
      run: terraform init -backend=false
      shell: bash
      working-directory: ${{ inputs.working-directory }}
    - name: Terraform validate
      id: validate
      run: terraform validate
      shell: bash
      working-directory: ${{ inputs.working-directory }}
    - name: Terraform init
      id: init
      run: terraform init
      shell: bash
      working-directory: ${{ inputs.working-directory }}
    - name: Terraform plan
      id: plan
      run: terraform plan -no-color -out=tfplan.out
      shell: bash
      working-directory: ${{ inputs.working-directory }}
    - name: Terraform apply
      id: apply
      run: |
        if [ ${{ inputs.apply }} = "true" ]; then
          terraform apply -input=false tfplan.out
        else
          echo 'User chose not to apply the Terraform plan stored in tfplan.out'
        fi
      shell: bash
      working-directory: ${{ inputs.working-directory }}
```

Cette action est compos√©e de plusieurs steps en grande partie repris de notre premier workflow. Le dernier step qui permet de lancer un `terraform apply` diff√®re un peu, on a rendu cette √©tape conditionnelle gr√¢ce √† un `if...then...else` en bash.

> Les actions peuvent avoir plusieurs inputs et outputs dans leur d√©finition.

Notre action poss√®de 2 inputs optionnels : `working-directory` et `apply`. Le premier permet de d√©finir le dossier de travail dans lequel chaque step sera ex√©cut√© et le deuxi√®me permet de rendre l‚Äôapply Terraform optionnel.

> Les inputs des actions sont n√©cessairement de type string au moment de l‚Äô√©criture de cet article.

Ce type d‚Äôaction a, √† mon sens, plusieurs d√©fauts √† l‚Äôheure actuelle :

- les steps de l‚Äôaction ne peuvent pas utiliser les m√™mes directives GitHub Actions que les steps d‚Äôun workflow. On ne pourra pas par exemple utiliser la directive `if` ou encore `continue-on-error` comme dans notre premier workflow. De la m√™me fa√ßon, on ne peut pas appeler une autre action avec la directive `uses` ;
- on est oblig√© de sp√©cifier la directive `shell` √† chaque `step`, ce qui est dommage car le shell √† utiliser peut √™tre d√©fini dans le workflow appelant l‚Äôaction et pourrait donc √™tre implicitement utilis√© ;
- on ne peut pas d√©finir un working-directory pour l‚Äôensemble de l‚Äôaction. Par d√©faut,  chaque step s‚Äôex√©cutera √† la racine de notre projet malgr√© le fait que le workflow appelant l‚Äôaction d√©finisse un espace de travail diff√©rent. On est donc oblig√© de surcharger ce param√®tre pour chaque step.

## Gestion du cycle de vie de notre application
Il est temps d‚Äôutiliser notre action dans un nouveau workflow `.github/workflows/gateway.yml` et dans un premier job `gateway-ecr` qui nous permettra de cr√©er le repository ECR sur AWS :

```yaml
jobs:
  gateway-ecr:
    defaults:
      run:
        working-directory: gateway/.cloud/terraform/10_ecr
    runs-on: ubuntu-latest
    outputs:
      gateway-ecr-repository-url-output: ${{ steps.terraform-output.outputs.gateway-ecr-repository-url }}
    steps:
      ...
      - name: Run Terraform workflow
        uses: ./.github/actions/terraform-workflow
        with:
          working-directory: 'gateway/.cloud/terraform/10_ecr'
      - name: Store ECR repository URL in an output variable
        id: terraform-output
        run: echo "::set-output name=gateway-ecr-repository-url::$(terraform output gateway_ecr_repository_url)"
```

Le step `terraform-output` permet d‚Äôexporter l‚ÄôURL du repository Docker ECR qui sera utilis√© dans le job suivant o√π l‚Äôon va construire l‚Äôimage de notre application Java. On utilise pour cela la commande de workflow `set-output` qui s‚Äôutilise comme suit :

```
::set-output name={name}::{value}
```

> Les commandes de workflow sont nombreuses et sont d√©crites [ici](https://docs.github.com/en/actions/reference/workflow-commands-for-github-actions).

On d√©clare en outputs du job un param√®tre qu‚Äôon appelle `gateway-ecr-repository-url-output` qui prend sa valeur depuis le dernier step du job.

On arrive maintenant au job `gateway-build` suivant qui va g√©rer le cycle de vie de notre application Java :


```yaml
  gateway-build:
    defaults:
      run:
        working-directory: gateway
    runs-on: ubuntu-latest
    needs: gateway-ecr
    container:
      image: taufort/infrastructure-ubuntu-docker:latest
    steps:
      - name: Checkout
        id: checkout
        uses: actions/checkout@v2
      - name: Set environment variables
        id: set-env-variables
        run: |
          echo "GATEWAY_ECR_REPOSITORY_URL=${{needs.gateway-ecr.outputs.gateway-ecr-repository-url-output}}" >> $GITHUB_ENV
          echo "ECR_REGISTRY_URI=$(echo ${{needs.gateway-ecr.outputs.gateway-ecr-repository-url-output}} | cut -d/ -f1)" >> $GITHUB_ENV
      - name: Print env variables
        id: print-env-variables
        run: |
          echo GATEWAY_ECR_REPOSITORY_URL=${{ env.GATEWAY_ECR_REPOSITORY_URL }}
          echo ECR_REGISTRY_URI=${{ env.ECR_REGISTRY_URI }}
      - name: Run maven clean verify
        id: maven-clean-verify
        run: ./mvnw clean verify
      - name: Build docker image
        id: maven-build-image
        run: ./mvnw -DskipTests spring-boot:build-image
      - name: Login to ECR
        id: ecr-login
        run: aws ecr get-login-password --region eu-west-3 | docker login --username AWS --password-stdin ${ECR_REGISTRY_URI}
      - name: Push the gateway docker image
        id: docker-push
        run: docker push ${GATEWAY_ECR_REPOSITORY_URL}:latest
```


On utilise la directive needs: `gateway-ecr` pour indiquer que ce nouveau job d√©pend du job pr√©c√©dent, cela permet d‚Äôordonner l‚Äôex√©cution des jobs.

A la diff√©rence des jobs pr√©c√©dents, celui-ci utilise la directive `container` qui permet d‚Äôindiquer √† GitHub Actions qu‚Äôon souhaite lancer les steps dans un container Docker d√©di√©. J‚Äôai utilis√© ici l‚Äô[une de mes images](https://github.com/taufort/infrastructure-ubuntu-docker) `image: taufort/infrastructure-ubuntu-docker:latest` contenant plusieurs binaires utiles √† l‚Äôex√©cution de ce job dont le CLI AWS, le CLI Docker ainsi que AdoptOpenJDK 15.

> Si on ne sp√©cifie pas de `container` dans un job, les steps s'ex√©cutent par d√©faut sur la machine h√¥te directement.

Le step `set-env-variables` est int√©ressant car on utilise [une nouvelle commande de workflow](https://docs.github.com/en/actions/reference/workflow-commands-for-github-actions#setting-an-environment-variable) pour d√©finir deux nouvelles variables d‚Äôenvironnement √† partir d‚Äôun output du job pr√©c√©dent :

```shell
echo "GATEWAY_ECR_REPOSITORY_URL=${{needs.gateway-ecr.outputs.gateway-ecr-repository-url-output}}" >> $GITHUB_ENV
```

On peut ensuite acc√©der √†  la variable d‚Äôenvironnement de plusieurs fa√ßons :

- via le contexte `env` fourni par GitHub Actions : `${{ env.GATEWAY_ECR_REPOSITORY_URL }}`
- ou bien directement via une variable shell : `${GATEWAY_ECR_REPOSITORY_URL}`

L‚Äôimage Docker de notre application Java est construite gr√¢ce √† [Buildpacks](https://buildpacks.io/) via le plugin Maven de Spring Boot `spring-boot-maven-plugin` o√π on r√©f√©rence justement cette variable d‚Äôenvironnement :

```xml
<build>
	<plugins>
		<plugin>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-maven-plugin</artifactId>
			<configuration>
				<image>
					<name>${env.GATEWAY_ECR_REPOSITORY_URL}</name>
				</image>
			</configuration>
		</plugin>
	</plugins>
</build>
```

Le dernier job du workflow `gateway` est assez simple et va se charger de d√©ployer l‚Äôimage Docker pr√©c√©demment cr√©√©e sur le cluster ECS Fargate via un service ECS :

```yaml
gateway-deploy:
    defaults:
      run:
        working-directory: gateway/.cloud/terraform/20_ecs
    runs-on: ubuntu-latest
    needs: gateway-build
    steps:
      - name: Checkout
        id: checkout
        uses: actions/checkout@v2
      - name: Setup Terraform
        id: setup
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: 0.14.7
          terraform_wrapper: false
      - name: Run Terraform workflow
        uses: ./.github/actions/terraform-workflow
        with:
          working-directory: 'gateway/.cloud/terraform/20_ecs'
```

Voil√† le r√©sultat de nos deux workflows et de leur 4 jobs dans une Pull Request (PR) :

![full_workflow.png](/assets/img/developpement/tempo/full_workflow.png)!

Notre application a √©t√© d√©ploy√©e sur AWS avec succ√®s :

![test.png](/assets/img/developpement/tempo/test.png)

## Que retenir ?
GitHub Actions existe depuis fin 2019 et offre un beau lot de fonctionnalit√©s pour un acteur si jeune dans le monde de la CI/CD. Il a l‚Äôavantage de s‚Äôint√©grer tr√®s facilement avec GitHub si vous avez pour habitude d‚Äôutiliser ce gestionnaire de sources. Les actions sont un moyen simple et √©l√©gant de rendre du code r√©utilisable dans les workflows, quel que soit leur type (Docker, JavaScript ou Composite). Ce syst√®me souffre malgr√© tout de quelques limitations comme nous avons pu le voir avec le type d‚Äôaction Composite. GitHub Actions est parfaitement adapt√© √† la gestion des monorepos, contrairement √† d‚Äôautres outils concurrents avec lesquels la mise en place est un peu plus compliqu√©e voir impossible (coucou GitLab CI et Jenkins). On regrettera l‚Äôabsence de possibilit√© d‚Äôordonner les workflows √† notre bon vouloir ou encore l‚Äôabsence d‚Äôexport d‚Äôartifacts qu‚Äôon pourrait se passer d‚Äôun job √† l‚Äôautre. Malgr√© tout, GitHub Actions est un outil qui m‚Äôa sembl√© solide et prometteur et qui pourrait rapidement devenir l‚Äôun des r√©f√©rents dans le domaine de la CI/CD.
  
Source : https://blog.ippon.fr/